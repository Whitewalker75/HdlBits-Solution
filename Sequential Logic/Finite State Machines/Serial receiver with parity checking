module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    parameter idle=0,start=1,s0=2,s1=3,s2=4,s3=5,s4=6,s5=7,s6=8,s7=9,stop=10,err=11,pari=12;
    reg[3:0] state,nstate;
    reg[7:0] data;
    wire odd,reset_p;
    reg done_reg;
    
    always@(*)begin
        case(state)
            idle:nstate<=in?idle:start;
            start: nstate<=s0;
            s0   : nstate<=s1;
            s1   : nstate<=s2;
            s2   : nstate<=s3;
            s3   : nstate<=s4;
            s4   : nstate<=s5;
            s5   : nstate<=s6;
            s6   : nstate<=s7;
            s7   : nstate<=pari;
            pari : nstate<=in?idle:err;
            err  : nstate<=in?idle:err;
        endcase
    end
    
    // Modify FSM and datapath from Fsm_serialdata
    always@(posedge clk)begin
        if(reset)begin
            state<=idle;
        end
        else begin
            state<=nstate;
        end
    end

    // New: Add parity checking.
    always@(posedge clk)begin
        if(reset)begin
            data=8'd0;
            reset_p<=1'b1;
            done_reg<=1'b0;
        end
        else begin
            if(nstate==s0||nstate==s1||nstate==s2||nstate==s3||nstate==s4||nstate==s5||nstate==s6||nstate==s7)begin
                data<={in,data[7:1]};
            end
            else if(nstate==start)begin
                data<=8'd0;
                reset_p<=1'b0;
                done_reg<=1'b0;
            end
            else if(nstate==idle)begin
                done_reg<=odd;
            end
            else if(nstate==pari)begin
                reset_p<=1'b1;
            end
        end
    end
    
    assign done =done_reg;
    assign out_byte=done?data:8'd0;
    parity par_mod(clk,reset|reset_p,in,odd);   
    

endmodule
