module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    reg [3:0] state,next_state;
    
    parameter S0 = 4'd0,S1 = 4'd1,S11 = 4'd2,S110 = 4'd3,B0 = 4'd4,B1 = 4'd5,B2 = 4'd6,B3 = 4'd7,Count = 4'd8,Wait = 4'd9;
    
    always@(posedge clk)begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    always@(*)begin
        case(state)
            S0:begin
                next_state <= data ? S1:S0;
                shift_ena <= 0;
            end
            S1:begin
                next_state <= data ? S11:S0;
                shift_ena <= 0;
            end
            S11:begin
                next_state <= data ? S11:S110;
                shift_ena <= 0;
            end
            S110:begin
                next_state <= data ? B0:S0;
                shift_ena <= 0;
            end
            B0:begin
                next_state <= B1;
                shift_ena <= 1;
            end
            B1:begin
                next_state <= B2;
                shift_ena <= 1;
            end
            B2:begin
                next_state <= B3;
                shift_ena <= 1;
            end
            B3:begin
                next_state <= Count;
                shift_ena <= 1;
            end
            Count:begin
                next_state <= done_counting ? Wait:Count;
                shift_ena <= 0;
            end
            Wait:begin
                next_state <= ack ? S0:Wait;
                shift_ena <= 0;
            end
            default:next_state <= S0;
        endcase
    end
    
    assign done = (state==Wait);
    assign counting = (state==Count);
endmodule
